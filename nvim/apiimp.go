// Code generated by running "go generate" in github.com/neovim/go-client/nvim. DO NOT EDIT.

package nvim

import (
	"fmt"

	"github.com/neovim/go-client/msgpack"
	"github.com/neovim/go-client/msgpack/rpc"
)

const (
	exceptionError  = 0
	validationError = 1
)

func withExtensions() rpc.Option {
	return rpc.WithExtensions(msgpack.ExtensionMap{

		0: func(p []byte) (interface{}, error) {
			x, err := decodeExt(p)
			return Buffer(x), err
		},

		2: func(p []byte) (interface{}, error) {
			x, err := decodeExt(p)
			return Tabpage(x), err
		},

		1: func(p []byte) (interface{}, error) {
			x, err := decodeExt(p)
			return Window(x), err
		},
	})
}

// Buffer represents a remote Nvim buffer.
type Buffer int

func (x *Buffer) UnmarshalMsgPack(dec *msgpack.Decoder) error {
	n, err := unmarshalExt(dec, 0, x)
	*x = Buffer(n)
	return err
}

func (x Buffer) MarshalMsgPack(enc *msgpack.Encoder) error {
	return enc.PackExtension(0, encodeExt(int(x)))
}

func (x Buffer) String() string {
	return fmt.Sprintf("Buffer:%d", int(x))
}

// Tabpage represents a remote Nvim tabpage.
type Tabpage int

func (x *Tabpage) UnmarshalMsgPack(dec *msgpack.Decoder) error {
	n, err := unmarshalExt(dec, 2, x)
	*x = Tabpage(n)
	return err
}

func (x Tabpage) MarshalMsgPack(enc *msgpack.Encoder) error {
	return enc.PackExtension(2, encodeExt(int(x)))
}

func (x Tabpage) String() string {
	return fmt.Sprintf("Tabpage:%d", int(x))
}

// Window represents a remote Nvim window.
type Window int

func (x *Window) UnmarshalMsgPack(dec *msgpack.Decoder) error {
	n, err := unmarshalExt(dec, 1, x)
	*x = Window(n)
	return err
}

func (x Window) MarshalMsgPack(enc *msgpack.Encoder) error {
	return enc.PackExtension(1, encodeExt(int(x)))
}

func (x Window) String() string {
	return fmt.Sprintf("Window:%d", int(x))
}

// BufferLineCount returns the number of lines in the buffer.
func (v *Nvim) BufferLineCount(buffer Buffer) (int, error) {
	var result int
	err := v.call("nvim_buf_line_count", &result, buffer)
	return result, err
}

// BufferLineCount returns the number of lines in the buffer.
func (b *Batch) BufferLineCount(buffer Buffer, result *int) {
	b.call("nvim_buf_line_count", result, buffer)
}

// BufferLines retrieves a line range from a buffer.
//
// Indexing is zero-based, end-exclusive. Negative indices are interpreted as
// length+1+index, i e -1 refers to the index past the end. So to get the last
// element set start=-2 and end=-1.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless strict
// = true.
func (v *Nvim) BufferLines(buffer Buffer, start int, end int, strict bool) ([][]byte, error) {
	var result [][]byte
	err := v.call("nvim_buf_get_lines", &result, buffer, start, end, strict)
	return result, err
}

// BufferLines retrieves a line range from a buffer.
//
// Indexing is zero-based, end-exclusive. Negative indices are interpreted as
// length+1+index, i e -1 refers to the index past the end. So to get the last
// element set start=-2 and end=-1.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless strict
// = true.
func (b *Batch) BufferLines(buffer Buffer, start int, end int, strict bool, result *[][]byte) {
	b.call("nvim_buf_get_lines", result, buffer, start, end, strict)
}

// AttachBuffer activate updates from this buffer to the current channel.
//
// If sendBuffer is true, initial notification should contain the whole buffer.
// If false, the first notification will be a `nvim_buf_lines_event`.
// Otherwise, the first notification will be a `nvim_buf_changedtick_event`
//
// opts is optional parameters. Currently not used.
//
// returns whether the updates couldn't be enabled because the buffer isn't loaded or opts contained an invalid key.
func (v *Nvim) AttachBuffer(buffer Buffer, sendBuffer bool, opts map[string]interface{}) (bool, error) {
	var result bool
	err := v.call("nvim_buf_attach", &result, buffer, sendBuffer, opts)
	return result, err
}

// AttachBuffer activate updates from this buffer to the current channel.
//
// If sendBuffer is true, initial notification should contain the whole buffer.
// If false, the first notification will be a `nvim_buf_lines_event`.
// Otherwise, the first notification will be a `nvim_buf_changedtick_event`
//
// opts is optional parameters. Currently not used.
//
// returns whether the updates couldn't be enabled because the buffer isn't loaded or opts contained an invalid key.
func (b *Batch) AttachBuffer(buffer Buffer, sendBuffer bool, opts map[string]interface{}, result *bool) {
	b.call("nvim_buf_attach", result, buffer, sendBuffer, opts)
}

// DetachBuffer deactivate updates from this buffer to the current channel.
//
// returns whether the updates couldn't be disabled because the buffer isn't loaded.
func (v *Nvim) DetachBuffer(buffer Buffer) (bool, error) {
	var result bool
	err := v.call("nvim_buf_detach", &result, buffer)
	return result, err
}

// DetachBuffer deactivate updates from this buffer to the current channel.
//
// returns whether the updates couldn't be disabled because the buffer isn't loaded.
func (b *Batch) DetachBuffer(buffer Buffer, result *bool) {
	b.call("nvim_buf_detach", result, buffer)
}

// SetBufferLines replaces a line range on a buffer.
//
// Indexing is zero-based, end-exclusive. Negative indices are interpreted as
// length+1+index, ie -1 refers to the index past the end. So to change or
// delete the last element set start=-2 and end=-1.
//
// To insert lines at a given index, set both start and end to the same index.
// To delete a range of lines, set replacement to an empty array.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless strict
// = true.
func (v *Nvim) SetBufferLines(buffer Buffer, start int, end int, strict bool, replacement [][]byte) error {
	return v.call("nvim_buf_set_lines", nil, buffer, start, end, strict, replacement)
}

// SetBufferLines replaces a line range on a buffer.
//
// Indexing is zero-based, end-exclusive. Negative indices are interpreted as
// length+1+index, ie -1 refers to the index past the end. So to change or
// delete the last element set start=-2 and end=-1.
//
// To insert lines at a given index, set both start and end to the same index.
// To delete a range of lines, set replacement to an empty array.
//
// Out-of-bounds indices are clamped to the nearest valid value, unless strict
// = true.
func (b *Batch) SetBufferLines(buffer Buffer, start int, end int, strict bool, replacement [][]byte) {
	b.call("nvim_buf_set_lines", nil, buffer, start, end, strict, replacement)
}

// BufferOffset returns the byte offset for a line.
//
// Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte.
// 'fileformat' and 'fileencoding' are ignored. The line index just after the
// last line gives the total byte-count of the buffer. A final EOL byte is
// counted if it would be written, see 'eol'.
//
// Unlike |line2byte()|, throws error for out-of-bounds indexing.
// Returns -1 for unloaded buffer.
func (v *Nvim) BufferOffset(buffer Buffer, index int) (int, error) {
	var result int
	err := v.call("nvim_buf_get_offset", &result, buffer, index)
	return result, err
}

// BufferOffset returns the byte offset for a line.
//
// Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is one byte.
// 'fileformat' and 'fileencoding' are ignored. The line index just after the
// last line gives the total byte-count of the buffer. A final EOL byte is
// counted if it would be written, see 'eol'.
//
// Unlike |line2byte()|, throws error for out-of-bounds indexing.
// Returns -1 for unloaded buffer.
func (b *Batch) BufferOffset(buffer Buffer, index int, result *int) {
	b.call("nvim_buf_get_offset", result, buffer, index)
}

// BufferVar gets a buffer-scoped (b:) variable.
func (v *Nvim) BufferVar(buffer Buffer, name string, result interface{}) error {
	return v.call("nvim_buf_get_var", result, buffer, name)
}

// BufferVar gets a buffer-scoped (b:) variable.
func (b *Batch) BufferVar(buffer Buffer, name string, result interface{}) {
	b.call("nvim_buf_get_var", result, buffer, name)
}

// BufferChangedTick gets a changed tick of a buffer.
func (v *Nvim) BufferChangedTick(buffer Buffer) (int, error) {
	var result int
	err := v.call("nvim_buf_get_changedtick", &result, buffer)
	return result, err
}

// BufferChangedTick gets a changed tick of a buffer.
func (b *Batch) BufferChangedTick(buffer Buffer, result *int) {
	b.call("nvim_buf_get_changedtick", result, buffer)
}

// BufferKeymap gets a list of buffer-local mappings.
func (v *Nvim) BufferKeyMap(buffer Buffer, mode string) ([]*Mapping, error) {
	var result []*Mapping
	err := v.call("nvim_buf_get_keymap", &result, buffer, mode)
	return result, err
}

// BufferKeymap gets a list of buffer-local mappings.
func (b *Batch) BufferKeyMap(buffer Buffer, mode string, result *[]*Mapping) {
	b.call("nvim_buf_get_keymap", result, buffer, mode)
}

// SetBufferKeyMap sets a buffer-local mapping for the given mode.
//
// see
//  :help nvim_set_keymap()
func (v *Nvim) SetBufferKeyMap(buffer Buffer, mode string, lhs string, rhs string, opts map[string]bool) error {
	return v.call("nvim_buf_set_keymap", nil, buffer, mode, lhs, rhs, opts)
}

// SetBufferKeyMap sets a buffer-local mapping for the given mode.
//
// see
//  :help nvim_set_keymap()
func (b *Batch) SetBufferKeyMap(buffer Buffer, mode string, lhs string, rhs string, opts map[string]bool) {
	b.call("nvim_buf_set_keymap", nil, buffer, mode, lhs, rhs, opts)
}

// DeleteBufferKeyMap unmaps a buffer-local mapping for the given mode.
//
// see
//  :help nvim_del_keymap()
func (v *Nvim) DeleteBufferKeyMap(buffer Buffer, mode string, lhs string) error {
	return v.call("nvim_buf_del_keymap", nil, buffer, mode, lhs)
}

// DeleteBufferKeyMap unmaps a buffer-local mapping for the given mode.
//
// see
//  :help nvim_del_keymap()
func (b *Batch) DeleteBufferKeyMap(buffer Buffer, mode string, lhs string) {
	b.call("nvim_buf_del_keymap", nil, buffer, mode, lhs)
}

// BufferCommands gets a map of buffer-local user-commands.
//
// opts is optional parameters. Currently not used.
func (v *Nvim) BufferCommands(buffer Buffer, opts map[string]interface{}) (map[string]*Command, error) {
	var result map[string]*Command
	err := v.call("nvim_buf_get_commands", &result, buffer, opts)
	return result, err
}

// BufferCommands gets a map of buffer-local user-commands.
//
// opts is optional parameters. Currently not used.
func (b *Batch) BufferCommands(buffer Buffer, opts map[string]interface{}, result *map[string]*Command) {
	b.call("nvim_buf_get_commands", result, buffer, opts)
}

// SetBufferVar sets a buffer-scoped (b:) variable.
func (v *Nvim) SetBufferVar(buffer Buffer, name string, value interface{}) error {
	return v.call("nvim_buf_set_var", nil, buffer, name, value)
}

// SetBufferVar sets a buffer-scoped (b:) variable.
func (b *Batch) SetBufferVar(buffer Buffer, name string, value interface{}) {
	b.call("nvim_buf_set_var", nil, buffer, name, value)
}

// DeleteBufferVar removes a buffer-scoped (b:) variable.
func (v *Nvim) DeleteBufferVar(buffer Buffer, name string) error {
	return v.call("nvim_buf_del_var", nil, buffer, name)
}

// DeleteBufferVar removes a buffer-scoped (b:) variable.
func (b *Batch) DeleteBufferVar(buffer Buffer, name string) {
	b.call("nvim_buf_del_var", nil, buffer, name)
}

// BufferOption gets a buffer option value.
func (v *Nvim) BufferOption(buffer Buffer, name string, result interface{}) error {
	return v.call("nvim_buf_get_option", result, buffer, name)
}

// BufferOption gets a buffer option value.
func (b *Batch) BufferOption(buffer Buffer, name string, result interface{}) {
	b.call("nvim_buf_get_option", result, buffer, name)
}

// SetBufferOption sets a buffer option value. The value nil deletes the option
// in the case where there's a global fallback.
func (v *Nvim) SetBufferOption(buffer Buffer, name string, value interface{}) error {
	return v.call("nvim_buf_set_option", nil, buffer, name, value)
}

// SetBufferOption sets a buffer option value. The value nil deletes the option
// in the case where there's a global fallback.
func (b *Batch) SetBufferOption(buffer Buffer, name string, value interface{}) {
	b.call("nvim_buf_set_option", nil, buffer, name, value)
}

// BufferNumber gets a buffer's number.
//
// Deprecated: Use int(buffer) to get the buffer's number as an integer.
func (v *Nvim) BufferNumber(buffer Buffer) (int, error) {
	var result int
	err := v.call("nvim_buf_get_number", &result, buffer)
	return result, err
}

// BufferNumber gets a buffer's number.
//
// Deprecated: Use int(buffer) to get the buffer's number as an integer.
func (b *Batch) BufferNumber(buffer Buffer, result *int) {
	b.call("nvim_buf_get_number", result, buffer)
}

// BufferName gets the full file name of a buffer.
func (v *Nvim) BufferName(buffer Buffer) (string, error) {
	var result string
	err := v.call("nvim_buf_get_name", &result, buffer)
	return result, err
}

// BufferName gets the full file name of a buffer.
func (b *Batch) BufferName(buffer Buffer, result *string) {
	b.call("nvim_buf_get_name", result, buffer)
}

// SetBufferName sets the full file name of a buffer.
// BufFilePre/BufFilePost are triggered.
func (v *Nvim) SetBufferName(buffer Buffer, name string) error {
	return v.call("nvim_buf_set_name", nil, buffer, name)
}

// SetBufferName sets the full file name of a buffer.
// BufFilePre/BufFilePost are triggered.
func (b *Batch) SetBufferName(buffer Buffer, name string) {
	b.call("nvim_buf_set_name", nil, buffer, name)
}

// IsBufferLoaded Checks if a buffer is valid and loaded.
// See api-buffer for more info about unloaded buffers.
func (v *Nvim) IsBufferLoaded(buffer Buffer) (bool, error) {
	var result bool
	err := v.call("nvim_buf_is_loaded", &result, buffer)
	return result, err
}

// IsBufferLoaded Checks if a buffer is valid and loaded.
// See api-buffer for more info about unloaded buffers.
func (b *Batch) IsBufferLoaded(buffer Buffer, result *bool) {
	b.call("nvim_buf_is_loaded", result, buffer)
}

// IsBufferValid returns true if the buffer is valid.
func (v *Nvim) IsBufferValid(buffer Buffer) (bool, error) {
	var result bool
	err := v.call("nvim_buf_is_valid", &result, buffer)
	return result, err
}

// IsBufferValid returns true if the buffer is valid.
func (b *Batch) IsBufferValid(buffer Buffer, result *bool) {
	b.call("nvim_buf_is_valid", result, buffer)
}

// BufferMark returns the (row,col) of the named mark.
func (v *Nvim) BufferMark(buffer Buffer, name string) ([2]int, error) {
	var result [2]int
	err := v.call("nvim_buf_get_mark", &result, buffer, name)
	return result, err
}

// BufferMark returns the (row,col) of the named mark.
func (b *Batch) BufferMark(buffer Buffer, name string, result *[2]int) {
	b.call("nvim_buf_get_mark", result, buffer, name)
}

// BufferExtmarkByID returns position for a given extmark id.
func (v *Nvim) BufferExtmarkByID(buffer Buffer, nsID int, id int) ([]int, error) {
	var result []int
	err := v.call("nvim_buf_get_extmark_by_id", &result, buffer, nsID, id)
	return result, err
}

// BufferExtmarkByID returns position for a given extmark id.
func (b *Batch) BufferExtmarkByID(buffer Buffer, nsID int, id int, result *[]int) {
	b.call("nvim_buf_get_extmark_by_id", result, buffer, nsID, id)
}

// BufferExtmarks list extmarks in a range (inclusive).
//
// range ends can be specified as (row, col) tuples, as well as extmark
// ids in the same namespace. In addition, 0 and -1 works as shorthands
// for (0,0) and (-1,-1) respectively, so that all marks in the buffer can be
// queried as:
//
//   allMarks = BufferExtmarks(0, my_ns, 0, -1, map[string]interface{})
//
// If end is a lower position than start, then the range will be traversed
// backwards. This is mostly useful with limited amount, to be able to get the
// first marks prior to a given position.
//
// opts is additional options. Supports the keys:
//   amount: Maximum number of marks to return.
func (v *Nvim) BufferExtmarks(buffer Buffer, nsID int, start interface{}, end interface{}, opt map[string]interface{}) ([]interface{}, error) {
	var result []interface{}
	err := v.call("nvim_buf_get_extmarks", &result, buffer, nsID, start, end, opt)
	return result, err
}

// BufferExtmarks list extmarks in a range (inclusive).
//
// range ends can be specified as (row, col) tuples, as well as extmark
// ids in the same namespace. In addition, 0 and -1 works as shorthands
// for (0,0) and (-1,-1) respectively, so that all marks in the buffer can be
// queried as:
//
//   allMarks = BufferExtmarks(0, my_ns, 0, -1, map[string]interface{})
//
// If end is a lower position than start, then the range will be traversed
// backwards. This is mostly useful with limited amount, to be able to get the
// first marks prior to a given position.
//
// opts is additional options. Supports the keys:
//   amount: Maximum number of marks to return.
func (b *Batch) BufferExtmarks(buffer Buffer, nsID int, start interface{}, end interface{}, opt map[string]interface{}, result *[]interface{}) {
	b.call("nvim_buf_get_extmarks", result, buffer, nsID, start, end, opt)
}

// SetBufferExtmark creates or updates an extmark at a position.
//
// If an invalid namespace is given, an error will be raised.
//
// To create a new extmark, pass in id=0. The new extmark id will be
// returned. To move an existing mark, pass in its id.
//
// It is also allowed to create a new mark by passing in a previously unused
// id, but the caller must then keep track of existing and unused ids itself.
// This is mainly useful over RPC, to avoid needing to wait for the return
// value.
//
// Currently opts arg not used.
func (v *Nvim) SetBufferExtmark(buffer Buffer, nsID int, id int, line int, col int, opts map[string]interface{}) (int, error) {
	var result int
	err := v.call("nvim_buf_set_extmark", &result, buffer, nsID, id, line, col, opts)
	return result, err
}

// SetBufferExtmark creates or updates an extmark at a position.
//
// If an invalid namespace is given, an error will be raised.
//
// To create a new extmark, pass in id=0. The new extmark id will be
// returned. To move an existing mark, pass in its id.
//
// It is also allowed to create a new mark by passing in a previously unused
// id, but the caller must then keep track of existing and unused ids itself.
// This is mainly useful over RPC, to avoid needing to wait for the return
// value.
//
// Currently opts arg not used.
func (b *Batch) SetBufferExtmark(buffer Buffer, nsID int, id int, line int, col int, opts map[string]interface{}, result *int) {
	b.call("nvim_buf_set_extmark", result, buffer, nsID, id, line, col, opts)
}

// DeleteBufferExtmark removes an extmark.
func (v *Nvim) DeleteBufferExtmark(buffer Buffer, nsID int, id int) (bool, error) {
	var result bool
	err := v.call("nvim_buf_del_extmark", &result, buffer, nsID, id)
	return result, err
}

// DeleteBufferExtmark removes an extmark.
func (b *Batch) DeleteBufferExtmark(buffer Buffer, nsID int, id int, result *bool) {
	b.call("nvim_buf_del_extmark", result, buffer, nsID, id)
}

// AddBufferHighlight adds a highlight to buffer and returns the source id of
// the highlight.
//
// AddBufferHighlight can be used for plugins which dynamically generate
// highlights to a buffer (like a semantic highlighter or linter). The function
// adds a single highlight to a buffer. Unlike matchaddpos() highlights follow
// changes to line numbering (as lines are inserted/removed above the
// highlighted line), like signs and marks do.
//
// The srcID is useful for batch deletion/updating of a set of highlights. When
// called with srcID = 0, an unique source id is generated and returned.
// Successive calls can pass in it as srcID to add new highlights to the same
// source group. All highlights in the same group can then be cleared with
// ClearBufferHighlight. If the highlight never will be manually deleted pass
// in -1 for srcID.
//
// If hlGroup is the empty string no highlight is added, but a new srcID is
// still returned. This is useful for an external plugin to synchronously
// request an unique srcID at initialization, and later asynchronously add and
// clear highlights in response to buffer changes.
//
// The startCol and endCol parameters specify the range of columns to
// highlight. Use endCol = -1 to highlight to the end of the line.
func (v *Nvim) AddBufferHighlight(buffer Buffer, srcID int, hlGroup string, line int, startCol int, endCol int) (int, error) {
	var result int
	err := v.call("nvim_buf_add_highlight", &result, buffer, srcID, hlGroup, line, startCol, endCol)
	return result, err
}

// AddBufferHighlight adds a highlight to buffer and returns the source id of
// the highlight.
//
// AddBufferHighlight can be used for plugins which dynamically generate
// highlights to a buffer (like a semantic highlighter or linter). The function
// adds a single highlight to a buffer. Unlike matchaddpos() highlights follow
// changes to line numbering (as lines are inserted/removed above the
// highlighted line), like signs and marks do.
//
// The srcID is useful for batch deletion/updating of a set of highlights. When
// called with srcID = 0, an unique source id is generated and returned.
// Successive calls can pass in it as srcID to add new highlights to the same
// source group. All highlights in the same group can then be cleared with
// ClearBufferHighlight. If the highlight never will be manually deleted pass
// in -1 for srcID.
//
// If hlGroup is the empty string no highlight is added, but a new srcID is
// still returned. This is useful for an external plugin to synchronously
// request an unique srcID at initialization, and later asynchronously add and
// clear highlights in response to buffer changes.
//
// The startCol and endCol parameters specify the range of columns to
// highlight. Use endCol = -1 to highlight to the end of the line.
func (b *Batch) AddBufferHighlight(buffer Buffer, srcID int, hlGroup string, line int, startCol int, endCol int, result *int) {
	b.call("nvim_buf_add_highlight", result, buffer, srcID, hlGroup, line, startCol, endCol)
}

// ClearBufferNamespace clears namespaced objects, highlights and virtual text, from a line range.
//
// To clear the namespace in the entire buffer, pass in 0 and -1 to
// line_start and line_end respectively.
func (v *Nvim) ClearBufferNamespace(buffer Buffer, nsID int, lineStart int, lineEnd int) error {
	return v.call("nvim_buf_clear_namespace", nil, buffer, nsID, lineStart, lineEnd)
}

// ClearBufferNamespace clears namespaced objects, highlights and virtual text, from a line range.
//
// To clear the namespace in the entire buffer, pass in 0 and -1 to
// line_start and line_end respectively.
func (b *Batch) ClearBufferNamespace(buffer Buffer, nsID int, lineStart int, lineEnd int) {
	b.call("nvim_buf_clear_namespace", nil, buffer, nsID, lineStart, lineEnd)
}

// ClearBufferHighlight clears highlights from a given source group and a range
// of lines.
//
// To clear a source group in the entire buffer, pass in 1 and -1 to startLine
// and endLine respectively.
//
// The lineStart and lineEnd parameters specify the range of lines to clear.
// The end of range is exclusive. Specify -1 to clear to the end of the file.
//
// Deprecated: Use ClearBufferNamespace() instead.
func (v *Nvim) ClearBufferHighlight(buffer Buffer, srcID int, startLine int, endLine int) error {
	return v.call("nvim_buf_clear_highlight", nil, buffer, srcID, startLine, endLine)
}

// ClearBufferHighlight clears highlights from a given source group and a range
// of lines.
//
// To clear a source group in the entire buffer, pass in 1 and -1 to startLine
// and endLine respectively.
//
// The lineStart and lineEnd parameters specify the range of lines to clear.
// The end of range is exclusive. Specify -1 to clear to the end of the file.
//
// Deprecated: Use ClearBufferNamespace() instead.
func (b *Batch) ClearBufferHighlight(buffer Buffer, srcID int, startLine int, endLine int) {
	b.call("nvim_buf_clear_highlight", nil, buffer, srcID, startLine, endLine)
}

// SetBufferVirtualText sets the virtual text (annotation) for a buffer line.
//
// By default (and currently the only option) the text will be placed after
// the buffer text. Virtual text will never cause reflow, rather virtual
// text will be truncated at the end of the screen line. The virtual text will
// begin one cell (|lcs-eol| or space) after the ordinary text.
//
// Namespaces are used to support batch deletion/updating of virtual text.
// To create a namespace, use CreateNamespace(). Virtual text is
// cleared using ClearBufferNamespace(). The same `nsID` can be used for
// both virtual text and highlights added by AddBufferHighlight(), both
// can then be cleared with a single call to ClearBufferNamespace(). If the
// virtual text never will be cleared by an API call, pass `nsID = -1`.
//
// As a shorthand, `nsID = 0` can be used to create a new namespace for the virtual text, the allocated id is then returned.
//
// The `opts` is optional parameters. Currently not used.
//
// The returns the nsID that was used.
func (v *Nvim) SetBufferVirtualText(buffer Buffer, nsID int, line int, chunks []VirtualTextChunk, opts map[string]interface{}) (int, error) {
	var result int
	err := v.call("nvim_buf_set_virtual_text", &result, buffer, nsID, line, chunks, opts)
	return result, err
}

// SetBufferVirtualText sets the virtual text (annotation) for a buffer line.
//
// By default (and currently the only option) the text will be placed after
// the buffer text. Virtual text will never cause reflow, rather virtual
// text will be truncated at the end of the screen line. The virtual text will
// begin one cell (|lcs-eol| or space) after the ordinary text.
//
// Namespaces are used to support batch deletion/updating of virtual text.
// To create a namespace, use CreateNamespace(). Virtual text is
// cleared using ClearBufferNamespace(). The same `nsID` can be used for
// both virtual text and highlights added by AddBufferHighlight(), both
// can then be cleared with a single call to ClearBufferNamespace(). If the
// virtual text never will be cleared by an API call, pass `nsID = -1`.
//
// As a shorthand, `nsID = 0` can be used to create a new namespace for the virtual text, the allocated id is then returned.
//
// The `opts` is optional parameters. Currently not used.
//
// The returns the nsID that was used.
func (b *Batch) SetBufferVirtualText(buffer Buffer, nsID int, line int, chunks []VirtualTextChunk, opts map[string]interface{}, result *int) {
	b.call("nvim_buf_set_virtual_text", result, buffer, nsID, line, chunks, opts)
}

// BufferVirtualText gets the virtual text (annotation) for a buffer line.
//
// The virtual text is returned as list of lists, whereas the inner lists have
// either one or two elements. The first element is the actual text, the
// optional second element is the highlight group.
//
// The format is exactly the same as given to SetBufferVirtualText.
//
// If there is no virtual text associated with the given line, an empty list
// is returned.
func (v *Nvim) BufferVirtualText(buffer Buffer, lnum int) ([]VirtualTextChunk, error) {
	var result []VirtualTextChunk
	err := v.call("nvim_buf_get_virtual_text", &result, buffer, lnum)
	return result, err
}

// BufferVirtualText gets the virtual text (annotation) for a buffer line.
//
// The virtual text is returned as list of lists, whereas the inner lists have
// either one or two elements. The first element is the actual text, the
// optional second element is the highlight group.
//
// The format is exactly the same as given to SetBufferVirtualText.
//
// If there is no virtual text associated with the given line, an empty list
// is returned.
func (b *Batch) BufferVirtualText(buffer Buffer, lnum int, result *[]VirtualTextChunk) {
	b.call("nvim_buf_get_virtual_text", result, buffer, lnum)
}

// TabpageWindows returns the windows in a tabpage.
func (v *Nvim) TabpageWindows(tabpage Tabpage) ([]Window, error) {
	var result []Window
	err := v.call("nvim_tabpage_list_wins", &result, tabpage)
	return result, err
}

// TabpageWindows returns the windows in a tabpage.
func (b *Batch) TabpageWindows(tabpage Tabpage, result *[]Window) {
	b.call("nvim_tabpage_list_wins", result, tabpage)
}

// TabpageVar gets a tab-scoped (t:) variable.
func (v *Nvim) TabpageVar(tabpage Tabpage, name string, result interface{}) error {
	return v.call("nvim_tabpage_get_var", result, tabpage, name)
}

// TabpageVar gets a tab-scoped (t:) variable.
func (b *Batch) TabpageVar(tabpage Tabpage, name string, result interface{}) {
	b.call("nvim_tabpage_get_var", result, tabpage, name)
}

// SetTabpageVar sets a tab-scoped (t:) variable.
func (v *Nvim) SetTabpageVar(tabpage Tabpage, name string, value interface{}) error {
	return v.call("nvim_tabpage_set_var", nil, tabpage, name, value)
}

// SetTabpageVar sets a tab-scoped (t:) variable.
func (b *Batch) SetTabpageVar(tabpage Tabpage, name string, value interface{}) {
	b.call("nvim_tabpage_set_var", nil, tabpage, name, value)
}

// DeleteTabpageVar removes a tab-scoped (t:) variable.
func (v *Nvim) DeleteTabpageVar(tabpage Tabpage, name string) error {
	return v.call("nvim_tabpage_del_var", nil, tabpage, name)
}

// DeleteTabpageVar removes a tab-scoped (t:) variable.
func (b *Batch) DeleteTabpageVar(tabpage Tabpage, name string) {
	b.call("nvim_tabpage_del_var", nil, tabpage, name)
}

// TabpageWindow gets the current window in a tab page.
func (v *Nvim) TabpageWindow(tabpage Tabpage) (Window, error) {
	var result Window
	err := v.call("nvim_tabpage_get_win", &result, tabpage)
	return result, err
}

// TabpageWindow gets the current window in a tab page.
func (b *Batch) TabpageWindow(tabpage Tabpage, result *Window) {
	b.call("nvim_tabpage_get_win", result, tabpage)
}

// TabpageNumber gets the tabpage number from the tabpage handle.
func (v *Nvim) TabpageNumber(tabpage Tabpage) (int, error) {
	var result int
	err := v.call("nvim_tabpage_get_number", &result, tabpage)
	return result, err
}

// TabpageNumber gets the tabpage number from the tabpage handle.
func (b *Batch) TabpageNumber(tabpage Tabpage, result *int) {
	b.call("nvim_tabpage_get_number", result, tabpage)
}

// IsTabpageValid checks if a tab page is valid.
func (v *Nvim) IsTabpageValid(tabpage Tabpage) (bool, error) {
	var result bool
	err := v.call("nvim_tabpage_is_valid", &result, tabpage)
	return result, err
}

// IsTabpageValid checks if a tab page is valid.
func (b *Batch) IsTabpageValid(tabpage Tabpage, result *bool) {
	b.call("nvim_tabpage_is_valid", result, tabpage)
}

// AttachUI registers the client as a remote UI. After this method is called,
// the client will receive redraw notifications.
//
//  :help rpc-remote-ui
//
// The redraw notification method has variadic arguments. Register a handler
// for the method like this:
//
//  v.RegisterHandler("redraw", func(updates ...[]interface{}) {
//      for _, update := range updates {
//          // handle update
//      }
//  })
func (v *Nvim) AttachUI(width int, height int, options map[string]interface{}) error {
	return v.call("nvim_ui_attach", nil, width, height, options)
}

// AttachUI registers the client as a remote UI. After this method is called,
// the client will receive redraw notifications.
//
//  :help rpc-remote-ui
//
// The redraw notification method has variadic arguments. Register a handler
// for the method like this:
//
//  v.RegisterHandler("redraw", func(updates ...[]interface{}) {
//      for _, update := range updates {
//          // handle update
//      }
//  })
func (b *Batch) AttachUI(width int, height int, options map[string]interface{}) {
	b.call("nvim_ui_attach", nil, width, height, options)
}

// DetachUI unregisters the client as a remote UI.
func (v *Nvim) DetachUI() error {
	return v.call("nvim_ui_detach", nil)
}

// DetachUI unregisters the client as a remote UI.
func (b *Batch) DetachUI() {
	b.call("nvim_ui_detach", nil)
}

// TryResizeUI notifies Nvim that the client window has resized. If possible,
// Nvim will send a redraw request to resize.
func (v *Nvim) TryResizeUI(width int, height int) error {
	return v.call("nvim_ui_try_resize", nil, width, height)
}

// TryResizeUI notifies Nvim that the client window has resized. If possible,
// Nvim will send a redraw request to resize.
func (b *Batch) TryResizeUI(width int, height int) {
	b.call("nvim_ui_try_resize", nil, width, height)
}

// SetUIOption sets a UI option.
func (v *Nvim) SetUIOption(name string, value interface{}) error {
	return v.call("nvim_ui_set_option", nil, name, value)
}

// SetUIOption sets a UI option.
func (b *Batch) SetUIOption(name string, value interface{}) {
	b.call("nvim_ui_set_option", nil, name, value)
}

// TryResizeUIGrid tell Nvim to resize a grid. Triggers a grid_resize event with the requested
// grid size or the maximum size if it exceeds size limits.
//
// On invalid grid handle, fails with error.
func (v *Nvim) TryResizeUIGrid(grid int, width int, height int) error {
	return v.call("nvim_ui_try_resize_grid", nil, grid, width, height)
}

// TryResizeUIGrid tell Nvim to resize a grid. Triggers a grid_resize event with the requested
// grid size or the maximum size if it exceeds size limits.
//
// On invalid grid handle, fails with error.
func (b *Batch) TryResizeUIGrid(grid int, width int, height int) {
	b.call("nvim_ui_try_resize_grid", nil, grid, width, height)
}

// SetPumHeight tells Nvim the number of elements displaying in the popumenu, to decide
// <PageUp> and <PageDown> movement.
//
// height is popupmenu height, must be greater than zero.
func (v *Nvim) SetPumHeight(height int) error {
	return v.call("nvim_ui_pum_set_height", nil, height)
}

// SetPumHeight tells Nvim the number of elements displaying in the popumenu, to decide
// <PageUp> and <PageDown> movement.
//
// height is popupmenu height, must be greater than zero.
func (b *Batch) SetPumHeight(height int) {
	b.call("nvim_ui_pum_set_height", nil, height)
}

// Command executes a single ex command.
func (v *Nvim) Command(cmd string) error {
	return v.call("nvim_command", nil, cmd)
}

// Command executes a single ex command.
func (b *Batch) Command(cmd string) {
	b.call("nvim_command", nil, cmd)
}

// HLByID gets a highlight definition by id.
func (v *Nvim) HLByID(id int, rgb bool) (*HLAttrs, error) {
	var result *HLAttrs
	err := v.call("nvim_get_hl_by_id", &result, id, rgb)
	return result, err
}

// HLByID gets a highlight definition by id.
func (b *Batch) HLByID(id int, rgb bool, result **HLAttrs) {
	b.call("nvim_get_hl_by_id", result, id, rgb)
}

// HLByName gets a highlight definition by name.
func (v *Nvim) HLByName(name string, rgb bool) (*HLAttrs, error) {
	var result *HLAttrs
	err := v.call("nvim_get_hl_by_name", &result, name, rgb)
	return result, err
}

// HLByName gets a highlight definition by name.
func (b *Batch) HLByName(name string, rgb bool, result **HLAttrs) {
	b.call("nvim_get_hl_by_name", result, name, rgb)
}

// FeedKeys Pushes keys to the Nvim user input buffer. Options can be a string
// with the following character flags:
//
//  m:  Remap keys. This is default.
//  n:  Do not remap keys.
//  t:  Handle keys as if typed; otherwise they are handled as if coming from a
//     mapping. This matters for undo, opening folds, etc.
func (v *Nvim) FeedKeys(keys string, mode string, escapeCSI bool) error {
	return v.call("nvim_feedkeys", nil, keys, mode, escapeCSI)
}

// FeedKeys Pushes keys to the Nvim user input buffer. Options can be a string
// with the following character flags:
//
//  m:  Remap keys. This is default.
//  n:  Do not remap keys.
//  t:  Handle keys as if typed; otherwise they are handled as if coming from a
//     mapping. This matters for undo, opening folds, etc.
func (b *Batch) FeedKeys(keys string, mode string, escapeCSI bool) {
	b.call("nvim_feedkeys", nil, keys, mode, escapeCSI)
}

// Input pushes bytes to the Nvim low level input buffer.
//
// Unlike FeedKeys, this uses the lowest level input buffer and the call is not
// deferred. It returns the number of bytes actually written(which can be less
// than what was requested if the buffer is full).
func (v *Nvim) Input(keys string) (int, error) {
	var result int
	err := v.call("nvim_input", &result, keys)
	return result, err
}

// Input pushes bytes to the Nvim low level input buffer.
//
// Unlike FeedKeys, this uses the lowest level input buffer and the call is not
// deferred. It returns the number of bytes actually written(which can be less
// than what was requested if the buffer is full).
func (b *Batch) Input(keys string, result *int) {
	b.call("nvim_input", result, keys)
}

// InputMouse send mouse event from GUI.
//
// The call is non-blocking. It doesn't wait on any resulting action, but
// queues the event to be processed soon by the event loop.
func (v *Nvim) InputMouse(button string, action string, modifier string, grid int, row int, col int) error {
	return v.call("nvim_input_mouse", nil, button, action, modifier, grid, row, col)
}

// InputMouse send mouse event from GUI.
//
// The call is non-blocking. It doesn't wait on any resulting action, but
// queues the event to be processed soon by the event loop.
func (b *Batch) InputMouse(button string, action string, modifier string, grid int, row int, col int) {
	b.call("nvim_input_mouse", nil, button, action, modifier, grid, row, col)
}

// ReplaceTermcodes replaces any terminal code strings by byte sequences. The
// returned sequences are Nvim's internal representation of keys, for example:
//
//  <esc> -> '\x1b'
//  <cr>  -> '\r'
//  <c-l> -> '\x0c'
//  <up>  -> '\x80ku'
//
// The returned sequences can be used as input to feedkeys.
func (v *Nvim) ReplaceTermcodes(str string, fromPart bool, doLT bool, special bool) (string, error) {
	var result string
	err := v.call("nvim_replace_termcodes", &result, str, fromPart, doLT, special)
	return result, err
}

// ReplaceTermcodes replaces any terminal code strings by byte sequences. The
// returned sequences are Nvim's internal representation of keys, for example:
//
//  <esc> -> '\x1b'
//  <cr>  -> '\r'
//  <c-l> -> '\x0c'
//  <up>  -> '\x80ku'
//
// The returned sequences can be used as input to feedkeys.
func (b *Batch) ReplaceTermcodes(str string, fromPart bool, doLT bool, special bool, result *string) {
	b.call("nvim_replace_termcodes", result, str, fromPart, doLT, special)
}

// CommandOutput executes a single ex command and returns the output.
func (v *Nvim) CommandOutput(cmd string) (string, error) {
	var result string
	err := v.call("nvim_command_output", &result, cmd)
	return result, err
}

// CommandOutput executes a single ex command and returns the output.
func (b *Batch) CommandOutput(cmd string, result *string) {
	b.call("nvim_command_output", result, cmd)
}

// Eval evaluates the expression expr using the Vim internal expression
// evaluator.
//
//  :help expression
func (v *Nvim) Eval(expr string, result interface{}) error {
	return v.call("nvim_eval", result, expr)
}

// Eval evaluates the expression expr using the Vim internal expression
// evaluator.
//
//  :help expression
func (b *Batch) Eval(expr string, result interface{}) {
	b.call("nvim_eval", result, expr)
}

// StringWidth returns the number of display cells the string occupies. Tab is
// counted as one cell.
func (v *Nvim) StringWidth(s string) (int, error) {
	var result int
	err := v.call("nvim_strwidth", &result, s)
	return result, err
}

// StringWidth returns the number of display cells the string occupies. Tab is
// counted as one cell.
func (b *Batch) StringWidth(s string, result *int) {
	b.call("nvim_strwidth", result, s)
}

// RuntimePaths returns a list of paths contained in the runtimepath option.
func (v *Nvim) RuntimePaths() ([]string, error) {
	var result []string
	err := v.call("nvim_list_runtime_paths", &result)
	return result, err
}

// RuntimePaths returns a list of paths contained in the runtimepath option.
func (b *Batch) RuntimePaths(result *[]string) {
	b.call("nvim_list_runtime_paths", result)
}

// SetCurrentDirectory changes the Vim working directory.
func (v *Nvim) SetCurrentDirectory(dir string) error {
	return v.call("nvim_set_current_dir", nil, dir)
}

// SetCurrentDirectory changes the Vim working directory.
func (b *Batch) SetCurrentDirectory(dir string) {
	b.call("nvim_set_current_dir", nil, dir)
}

// CurrentLine gets the current line in the current buffer.
func (v *Nvim) CurrentLine() ([]byte, error) {
	var result []byte
	err := v.call("nvim_get_current_line", &result)
	return result, err
}

// CurrentLine gets the current line in the current buffer.
func (b *Batch) CurrentLine(result *[]byte) {
	b.call("nvim_get_current_line", result)
}

// SetCurrentLine sets the current line in the current buffer.
func (v *Nvim) SetCurrentLine(line []byte) error {
	return v.call("nvim_set_current_line", nil, line)
}

// SetCurrentLine sets the current line in the current buffer.
func (b *Batch) SetCurrentLine(line []byte) {
	b.call("nvim_set_current_line", nil, line)
}

// DeleteCurrentLine deletes the current line in the current buffer.
func (v *Nvim) DeleteCurrentLine() error {
	return v.call("nvim_del_current_line", nil)
}

// DeleteCurrentLine deletes the current line in the current buffer.
func (b *Batch) DeleteCurrentLine() {
	b.call("nvim_del_current_line", nil)
}

// Var gets a global (g:) variable.
func (v *Nvim) Var(name string, result interface{}) error {
	return v.call("nvim_get_var", result, name)
}

// Var gets a global (g:) variable.
func (b *Batch) Var(name string, result interface{}) {
	b.call("nvim_get_var", result, name)
}

// SetVar sets a global (g:) variable.
func (v *Nvim) SetVar(name string, value interface{}) error {
	return v.call("nvim_set_var", nil, name, value)
}

// SetVar sets a global (g:) variable.
func (b *Batch) SetVar(name string, value interface{}) {
	b.call("nvim_set_var", nil, name, value)
}

// DeleteVar removes a global (g:) variable.
func (v *Nvim) DeleteVar(name string) error {
	return v.call("nvim_del_var", nil, name)
}

// DeleteVar removes a global (g:) variable.
func (b *Batch) DeleteVar(name string) {
	b.call("nvim_del_var", nil, name)
}

// VVar gets a vim (v:) variable.
func (v *Nvim) VVar(name string, result interface{}) error {
	return v.call("nvim_get_vvar", result, name)
}

// VVar gets a vim (v:) variable.
func (b *Batch) VVar(name string, result interface{}) {
	b.call("nvim_get_vvar", result, name)
}

// SetVVar sets a v: variable, if it is not readonly.
func (v *Nvim) SetVVar(name string, value interface{}) error {
	return v.call("nvim_set_vvar", nil, name, value)
}

// SetVVar sets a v: variable, if it is not readonly.
func (b *Batch) SetVVar(name string, value interface{}) {
	b.call("nvim_set_vvar", nil, name, value)
}

// Option gets an option.
func (v *Nvim) Option(name string, result interface{}) error {
	return v.call("nvim_get_option", result, name)
}

// Option gets an option.
func (b *Batch) Option(name string, result interface{}) {
	b.call("nvim_get_option", result, name)
}

// SetOption sets an option.
func (v *Nvim) SetOption(name string, value interface{}) error {
	return v.call("nvim_set_option", nil, name, value)
}

// SetOption sets an option.
func (b *Batch) SetOption(name string, value interface{}) {
	b.call("nvim_set_option", nil, name, value)
}

// WriteOut writes a message to vim output buffer. The string is split and
// flushed after each newline. Incomplete lines are kept for writing later.
func (v *Nvim) WriteOut(str string) error {
	return v.call("nvim_out_write", nil, str)
}

// WriteOut writes a message to vim output buffer. The string is split and
// flushed after each newline. Incomplete lines are kept for writing later.
func (b *Batch) WriteOut(str string) {
	b.call("nvim_out_write", nil, str)
}

// WriteErr writes a message to vim error buffer. The string is split and
// flushed after each newline. Incomplete lines are kept for writing later.
func (v *Nvim) WriteErr(str string) error {
	return v.call("nvim_err_write", nil, str)
}

// WriteErr writes a message to vim error buffer. The string is split and
// flushed after each newline. Incomplete lines are kept for writing later.
func (b *Batch) WriteErr(str string) {
	b.call("nvim_err_write", nil, str)
}

// WritelnErr writes prints str and a newline as an error message.
func (v *Nvim) WritelnErr(str string) error {
	return v.call("nvim_err_writeln", nil, str)
}

// WritelnErr writes prints str and a newline as an error message.
func (b *Batch) WritelnErr(str string) {
	b.call("nvim_err_writeln", nil, str)
}

// Buffers returns the current list of buffers.
func (v *Nvim) Buffers() ([]Buffer, error) {
	var result []Buffer
	err := v.call("nvim_list_bufs", &result)
	return result, err
}

// Buffers returns the current list of buffers.
func (b *Batch) Buffers(result *[]Buffer) {
	b.call("nvim_list_bufs", result)
}

// CurrentBuffer returns the current buffer.
func (v *Nvim) CurrentBuffer() (Buffer, error) {
	var result Buffer
	err := v.call("nvim_get_current_buf", &result)
	return result, err
}

// CurrentBuffer returns the current buffer.
func (b *Batch) CurrentBuffer(result *Buffer) {
	b.call("nvim_get_current_buf", result)
}

// SetCurrentBuffer sets the current buffer.
func (v *Nvim) SetCurrentBuffer(buffer Buffer) error {
	return v.call("nvim_set_current_buf", nil, buffer)
}

// SetCurrentBuffer sets the current buffer.
func (b *Batch) SetCurrentBuffer(buffer Buffer) {
	b.call("nvim_set_current_buf", nil, buffer)
}

// Windows returns the current list of windows.
func (v *Nvim) Windows() ([]Window, error) {
	var result []Window
	err := v.call("nvim_list_wins", &result)
	return result, err
}

// Windows returns the current list of windows.
func (b *Batch) Windows(result *[]Window) {
	b.call("nvim_list_wins", result)
}

// CurrentWindow returns the current window.
func (v *Nvim) CurrentWindow() (Window, error) {
	var result Window
	err := v.call("nvim_get_current_win", &result)
	return result, err
}

// CurrentWindow returns the current window.
func (b *Batch) CurrentWindow(result *Window) {
	b.call("nvim_get_current_win", result)
}

// SetCurrentWindow sets the current window.
func (v *Nvim) SetCurrentWindow(window Window) error {
	return v.call("nvim_set_current_win", nil, window)
}

// SetCurrentWindow sets the current window.
func (b *Batch) SetCurrentWindow(window Window) {
	b.call("nvim_set_current_win", nil, window)
}

// CreateBuffer creates a new, empty, unnamed buffer.
func (v *Nvim) CreateBuffer(listed bool, scratch bool) (Buffer, error) {
	var result Buffer
	err := v.call("nvim_create_buf", &result, listed, scratch)
	return result, err
}

// CreateBuffer creates a new, empty, unnamed buffer.
func (b *Batch) CreateBuffer(listed bool, scratch bool, result *Buffer) {
	b.call("nvim_create_buf", result, listed, scratch)
}

// OpenWindow opens a new window.
//
// Currently this is used to open floating and external windows.
// Floats are windows that are drawn above the split layout, at some anchor
// position in some other window. Floats can be drawn internally or by external
// GUI with the |ui-multigrid| extension. External windows are only supported
// with multigrid GUIs, and are displayed as separate top-level windows.
//
// For a general overview of floats, see |api-floatwin|.
//
// Exactly one of External and Relative must be specified. The Width and
// Height of the new window must be specified.
//
// With relative=editor (row=0,col=0) refers to the top-left corner of the
// screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right
// corner. Fractional values are allowed, but the builtin implementation
// (used by non-multigrid UIs) will always round down to nearest integer.
//
// Out-of-bounds values, and configurations that make the float not fit inside
// the main editor, are allowed. The builtin implementation truncates values
// so floats are fully within the main screen grid. External GUIs
// could let floats hover outside of the main window like a tooltip, but
// this should not be used to specify arbitrary WM screen positions.
//
// The returns the window handle or 0 when error.
func (v *Nvim) OpenWindow(buffer Buffer, enter bool, config *WindowConfig) (Window, error) {
	var result Window
	err := v.call("nvim_open_win", &result, buffer, enter, config)
	return result, err
}

// OpenWindow opens a new window.
//
// Currently this is used to open floating and external windows.
// Floats are windows that are drawn above the split layout, at some anchor
// position in some other window. Floats can be drawn internally or by external
// GUI with the |ui-multigrid| extension. External windows are only supported
// with multigrid GUIs, and are displayed as separate top-level windows.
//
// For a general overview of floats, see |api-floatwin|.
//
// Exactly one of External and Relative must be specified. The Width and
// Height of the new window must be specified.
//
// With relative=editor (row=0,col=0) refers to the top-left corner of the
// screen-grid and (row=Lines-1,col=Columns-1) refers to the bottom-right
// corner. Fractional values are allowed, but the builtin implementation
// (used by non-multigrid UIs) will always round down to nearest integer.
//
// Out-of-bounds values, and configurations that make the float not fit inside
// the main editor, are allowed. The builtin implementation truncates values
// so floats are fully within the main screen grid. External GUIs
// could let floats hover outside of the main window like a tooltip, but
// this should not be used to specify arbitrary WM screen positions.
//
// The returns the window handle or 0 when error.
func (b *Batch) OpenWindow(buffer Buffer, enter bool, config *WindowConfig, result *Window) {
	b.call("nvim_open_win", result, buffer, enter, config)
}

// Tabpages returns the current list of tabpages.
func (v *Nvim) Tabpages() ([]Tabpage, error) {
	var result []Tabpage
	err := v.call("nvim_list_tabpages", &result)
	return result, err
}

// Tabpages returns the current list of tabpages.
func (b *Batch) Tabpages(result *[]Tabpage) {
	b.call("nvim_list_tabpages", result)
}

// CurrentTabpage returns the current tabpage.
func (v *Nvim) CurrentTabpage() (Tabpage, error) {
	var result Tabpage
	err := v.call("nvim_get_current_tabpage", &result)
	return result, err
}

// CurrentTabpage returns the current tabpage.
func (b *Batch) CurrentTabpage(result *Tabpage) {
	b.call("nvim_get_current_tabpage", result)
}

// SetCurrentTabpage sets the current tabpage.
func (v *Nvim) SetCurrentTabpage(tabpage Tabpage) error {
	return v.call("nvim_set_current_tabpage", nil, tabpage)
}

// SetCurrentTabpage sets the current tabpage.
func (b *Batch) SetCurrentTabpage(tabpage Tabpage) {
	b.call("nvim_set_current_tabpage", nil, tabpage)
}

// CreateNamespace creates a new namespace, or gets an existing one.
//
// Namespaces are used for buffer highlights and virtual text, see
// AddBufferHighlight() and SetBufferVirtualText().
//
// Namespaces can be named or anonymous. If `name` matches an existing
// namespace, the associated id is returned. If `name` is an empty string
// a new, anonymous namespace is created.
//
// The returns the namespace ID.
func (v *Nvim) CreateNamespace(name string) (int, error) {
	var result int
	err := v.call("nvim_create_namespace", &result, name)
	return result, err
}

// CreateNamespace creates a new namespace, or gets an existing one.
//
// Namespaces are used for buffer highlights and virtual text, see
// AddBufferHighlight() and SetBufferVirtualText().
//
// Namespaces can be named or anonymous. If `name` matches an existing
// namespace, the associated id is returned. If `name` is an empty string
// a new, anonymous namespace is created.
//
// The returns the namespace ID.
func (b *Batch) CreateNamespace(name string, result *int) {
	b.call("nvim_create_namespace", result, name)
}

// Namespaces gets existing named namespaces
//
// The return dict that maps from names to namespace ids.
func (v *Nvim) Namespaces() (map[string]int, error) {
	var result map[string]int
	err := v.call("nvim_get_namespaces", &result)
	return result, err
}

// Namespaces gets existing named namespaces
//
// The return dict that maps from names to namespace ids.
func (b *Batch) Namespaces(result *map[string]int) {
	b.call("nvim_get_namespaces", result)
}

// Paste pastes at cursor, in any mode.
//
// Invokes the `vim.paste` handler, which handles each mode appropriately.
// Sets redo/undo. Faster than |nvim_input()|. Lines break at LF ("\n").
//
// Errors ('nomodifiable', `vim.paste()` failure, …) are reflected in `err`
// but do not affect the return value (which is strictly decided by
// `vim.paste()`).  On error, subsequent calls are ignored ("drained") until
// the next paste is initiated (phase 1 or -1).
//
// data: multiline input. May be binary (containing NUL bytes).
// crlf: also break lines at CR and CRLF.
// phase: -1 is paste in a single call (i.e. without streaming).
// To "stream" a paste, call `nvim_paste` sequentially with these `phase` values:
//   1: starts the paste (exactly once)
//   2: continues the paste (zero or more times)
//   3: ends the paste (exactly once)
func (v *Nvim) Paste(data string, crlf bool, phase int) (bool, error) {
	var result bool
	err := v.call("nvim_paste", &result, data, crlf, phase)
	return result, err
}

// Paste pastes at cursor, in any mode.
//
// Invokes the `vim.paste` handler, which handles each mode appropriately.
// Sets redo/undo. Faster than |nvim_input()|. Lines break at LF ("\n").
//
// Errors ('nomodifiable', `vim.paste()` failure, …) are reflected in `err`
// but do not affect the return value (which is strictly decided by
// `vim.paste()`).  On error, subsequent calls are ignored ("drained") until
// the next paste is initiated (phase 1 or -1).
//
// data: multiline input. May be binary (containing NUL bytes).
// crlf: also break lines at CR and CRLF.
// phase: -1 is paste in a single call (i.e. without streaming).
// To "stream" a paste, call `nvim_paste` sequentially with these `phase` values:
//   1: starts the paste (exactly once)
//   2: continues the paste (zero or more times)
//   3: ends the paste (exactly once)
func (b *Batch) Paste(data string, crlf bool, phase int, result *bool) {
	b.call("nvim_paste", result, data, crlf, phase)
}

// Put puts text at cursor, in any mode.
//
// Compare |:put| and |p| which are always linewise.
//
// lines is |readfile()|-style list of lines. |channel-lines|
//
// type is edit behavior: any |getregtype()| result, or:
//   "b" |blockwise-visual| mode (may include width, e.g. "b3")
//   "c" |characterwise| mode
//   "l" |linewise| mode
//   ""  guess by contents, see |setreg()|
// after is insert after cursor (like |p|), or before (like |P|).
//
// follow is place cursor at end of inserted text.
func (v *Nvim) Put(lines []string, typ string, after bool, follow bool) error {
	return v.call("nvim_put", nil, lines, typ, after, follow)
}

// Put puts text at cursor, in any mode.
//
// Compare |:put| and |p| which are always linewise.
//
// lines is |readfile()|-style list of lines. |channel-lines|
//
// type is edit behavior: any |getregtype()| result, or:
//   "b" |blockwise-visual| mode (may include width, e.g. "b3")
//   "c" |characterwise| mode
//   "l" |linewise| mode
//   ""  guess by contents, see |setreg()|
// after is insert after cursor (like |p|), or before (like |P|).
//
// follow is place cursor at end of inserted text.
func (b *Batch) Put(lines []string, typ string, after bool, follow bool) {
	b.call("nvim_put", nil, lines, typ, after, follow)
}

// Subscribe subscribes to a Nvim event.
func (v *Nvim) Subscribe(event string) error {
	return v.call("nvim_subscribe", nil, event)
}

// Subscribe subscribes to a Nvim event.
func (b *Batch) Subscribe(event string) {
	b.call("nvim_subscribe", nil, event)
}

// Unsubscribe unsubscribes to a Nvim event.
func (v *Nvim) Unsubscribe(event string) error {
	return v.call("nvim_unsubscribe", nil, event)
}

// Unsubscribe unsubscribes to a Nvim event.
func (b *Batch) Unsubscribe(event string) {
	b.call("nvim_unsubscribe", nil, event)
}

func (v *Nvim) ColorByName(name string) (int, error) {
	var result int
	err := v.call("nvim_get_color_by_name", &result, name)
	return result, err
}

func (b *Batch) ColorByName(name string, result *int) {
	b.call("nvim_get_color_by_name", result, name)
}

func (v *Nvim) ColorMap() (map[string]int, error) {
	var result map[string]int
	err := v.call("nvim_get_color_map", &result)
	return result, err
}

func (b *Batch) ColorMap(result *map[string]int) {
	b.call("nvim_get_color_map", result)
}

// Context gets a map of the current editor state.
//
// opts is Optional parameters.
// types: List of |context-types| ("regs", "jumps", "bufs", "gvars" or etc) to gather, or empty for "all".
func (v *Nvim) Context(opts map[string][]string) (map[string]interface{}, error) {
	var result map[string]interface{}
	err := v.call("nvim_get_context", &result, opts)
	return result, err
}

// Context gets a map of the current editor state.
//
// opts is Optional parameters.
// types: List of |context-types| ("regs", "jumps", "bufs", "gvars" or etc) to gather, or empty for "all".
func (b *Batch) Context(opts map[string][]string, result *map[string]interface{}) {
	b.call("nvim_get_context", result, opts)
}

// LoadContext sets the current editor state from the given |context| map.
func (v *Nvim) LoadContext(dict map[string]interface{}, result interface{}) error {
	return v.call("nvim_load_context", result, dict)
}

// LoadContext sets the current editor state from the given |context| map.
func (b *Batch) LoadContext(dict map[string]interface{}, result interface{}) {
	b.call("nvim_load_context", result, dict)
}

// Mode gets Nvim's current mode.
func (v *Nvim) Mode() (*Mode, error) {
	var result Mode
	err := v.call("nvim_get_mode", &result)
	return &result, err
}

// Mode gets Nvim's current mode.
func (b *Batch) Mode(result *Mode) {
	b.call("nvim_get_mode", result)
}

func (v *Nvim) KeyMap(mode string) ([]*Mapping, error) {
	var result []*Mapping
	err := v.call("nvim_get_keymap", &result, mode)
	return result, err
}

func (b *Batch) KeyMap(mode string, result *[]*Mapping) {
	b.call("nvim_get_keymap", result, mode)
}

// SetKeyMap sets a global |mapping| for the given mode.
//
// To set a buffer-local mapping, use SetBufferKeyMap().
//
// Unlike :map, leading/trailing whitespace is accepted as part of the {lhs}
// or {rhs}.
// Empty {rhs} is <Nop>. keycodes are replaced as usual.
//
//  mode
// mode short-name (map command prefix: "n", "i", "v", "x", …) or "!" for :map!, or empty string for :map.
//
//  lhs
// Left-hand-side {lhs} of the mapping.
//
//  rhs
// Right-hand-side {rhs} of the mapping.
//
//  opts
// Optional parameters map. Accepts all :map-arguments as keys excluding <buffer> but including noremap.
// Values are Booleans. Unknown key is an error.
func (v *Nvim) SetKeyMap(mode string, lhs string, rhs string, opts map[string]bool) error {
	return v.call("nvim_set_keymap", nil, mode, lhs, rhs, opts)
}

// SetKeyMap sets a global |mapping| for the given mode.
//
// To set a buffer-local mapping, use SetBufferKeyMap().
//
// Unlike :map, leading/trailing whitespace is accepted as part of the {lhs}
// or {rhs}.
// Empty {rhs} is <Nop>. keycodes are replaced as usual.
//
//  mode
// mode short-name (map command prefix: "n", "i", "v", "x", …) or "!" for :map!, or empty string for :map.
//
//  lhs
// Left-hand-side {lhs} of the mapping.
//
//  rhs
// Right-hand-side {rhs} of the mapping.
//
//  opts
// Optional parameters map. Accepts all :map-arguments as keys excluding <buffer> but including noremap.
// Values are Booleans. Unknown key is an error.
func (b *Batch) SetKeyMap(mode string, lhs string, rhs string, opts map[string]bool) {
	b.call("nvim_set_keymap", nil, mode, lhs, rhs, opts)
}

// DeleteKeyMap unmaps a global mapping for the given mode.
//
// To unmap a buffer-local mapping, use DeleteBufferKeyMap().
//
// see
//  :help nvim_set_keymap()
func (v *Nvim) DeleteKeyMap(mode string, lhs string) error {
	return v.call("nvim_del_keymap", nil, mode, lhs)
}

// DeleteKeyMap unmaps a global mapping for the given mode.
//
// To unmap a buffer-local mapping, use DeleteBufferKeyMap().
//
// see
//  :help nvim_set_keymap()
func (b *Batch) DeleteKeyMap(mode string, lhs string) {
	b.call("nvim_del_keymap", nil, mode, lhs)
}

// Commands gets a map of global (non-buffer-local) Ex commands.
// Currently only user-commands are supported, not builtin Ex commands.
//
// opts is optional parameters. Currently only supports {"builtin":false}.
func (v *Nvim) Commands(opts map[string]interface{}) (map[string]*Command, error) {
	var result map[string]*Command
	err := v.call("nvim_get_commands", &result, opts)
	return result, err
}

// Commands gets a map of global (non-buffer-local) Ex commands.
// Currently only user-commands are supported, not builtin Ex commands.
//
// opts is optional parameters. Currently only supports {"builtin":false}.
func (b *Batch) Commands(opts map[string]interface{}, result *map[string]*Command) {
	b.call("nvim_get_commands", result, opts)
}

func (v *Nvim) APIInfo() ([]interface{}, error) {
	var result []interface{}
	err := v.call("nvim_get_api_info", &result)
	return result, err
}

func (b *Batch) APIInfo(result *[]interface{}) {
	b.call("nvim_get_api_info", result)
}

// SetClientInfo identify the client for nvim.
//
// Can be called more than once, but subsequent calls will remove earlier info, which should be resent if it is still valid.
// (This could happen if a library first identifies the channel, and a plugin using that library later overrides that info)
func (v *Nvim) SetClientInfo(name string, version *ClientVersion, typ string, methods map[string]*ClientMethod, attributes ClientAttributes) error {
	return v.call("nvim_set_client_info", nil, name, version, typ, methods, attributes)
}

// SetClientInfo identify the client for nvim.
//
// Can be called more than once, but subsequent calls will remove earlier info, which should be resent if it is still valid.
// (This could happen if a library first identifies the channel, and a plugin using that library later overrides that info)
func (b *Batch) SetClientInfo(name string, version *ClientVersion, typ string, methods map[string]*ClientMethod, attributes ClientAttributes) {
	b.call("nvim_set_client_info", nil, name, version, typ, methods, attributes)
}

// ChannelInfo get information about a channel.
func (v *Nvim) ChannelInfo(channel int) (*Channel, error) {
	var result *Channel
	err := v.call("nvim_get_chan_info", &result, channel)
	return result, err
}

// ChannelInfo get information about a channel.
func (b *Batch) ChannelInfo(channel int, result **Channel) {
	b.call("nvim_get_chan_info", result, channel)
}

// Channels get information about all open channels.
func (v *Nvim) Channels() ([]*Channel, error) {
	var result []*Channel
	err := v.call("nvim_list_chans", &result)
	return result, err
}

// Channels get information about all open channels.
func (b *Batch) Channels(result *[]*Channel) {
	b.call("nvim_list_chans", result)
}

// ParseExpression parse a VimL expression.
func (v *Nvim) ParseExpression(expr string, flags string, highlight bool) (map[string]interface{}, error) {
	var result map[string]interface{}
	err := v.call("nvim_parse_expression", &result, expr, flags, highlight)
	return result, err
}

// ParseExpression parse a VimL expression.
func (b *Batch) ParseExpression(expr string, flags string, highlight bool, result *map[string]interface{}) {
	b.call("nvim_parse_expression", result, expr, flags, highlight)
}

// UIs gets a list of dictionaries representing attached UIs.
func (v *Nvim) UIs() ([]*UI, error) {
	var result []*UI
	err := v.call("nvim_list_uis", &result)
	return result, err
}

// UIs gets a list of dictionaries representing attached UIs.
func (b *Batch) UIs(result *[]*UI) {
	b.call("nvim_list_uis", result)
}

// ProcChildren gets the immediate children of process `pid`.
func (v *Nvim) ProcChildren(pid int) ([]*Process, error) {
	var result []*Process
	err := v.call("nvim_get_proc_children", &result, pid)
	return result, err
}

// ProcChildren gets the immediate children of process `pid`.
func (b *Batch) ProcChildren(pid int, result *[]*Process) {
	b.call("nvim_get_proc_children", result, pid)
}

// Proc gets info describing process `pid`.
func (v *Nvim) Proc(pid int) (Process, error) {
	var result Process
	err := v.call("nvim_get_proc", &result, pid)
	return result, err
}

// Proc gets info describing process `pid`.
func (b *Batch) Proc(pid int, result *Process) {
	b.call("nvim_get_proc", result, pid)
}

// SelectPopupmenuItem selects an item in the completion popupmenu.
//
// If |ins-completion| is not active this API call is silently ignored.
// Useful for an external UI using |ui-popupmenu| to control the popupmenu
// with the mouse. Can also be used in a mapping; use <cmd> |:map-cmd| to
// ensure the mapping doesn't end completion mode.
//
// The `opts` optional parameters. Reserved for future use.
func (v *Nvim) SelectPopupmenuItem(item int, insert bool, finish bool, opts map[string]interface{}) error {
	return v.call("nvim_select_popupmenu_item", nil, item, insert, finish, opts)
}

// SelectPopupmenuItem selects an item in the completion popupmenu.
//
// If |ins-completion| is not active this API call is silently ignored.
// Useful for an external UI using |ui-popupmenu| to control the popupmenu
// with the mouse. Can also be used in a mapping; use <cmd> |:map-cmd| to
// ensure the mapping doesn't end completion mode.
//
// The `opts` optional parameters. Reserved for future use.
func (b *Batch) SelectPopupmenuItem(item int, insert bool, finish bool, opts map[string]interface{}) {
	b.call("nvim_select_popupmenu_item", nil, item, insert, finish, opts)
}

// WindowBuffer returns the current buffer in a window.
func (v *Nvim) WindowBuffer(window Window) (Buffer, error) {
	var result Buffer
	err := v.call("nvim_win_get_buf", &result, window)
	return result, err
}

// WindowBuffer returns the current buffer in a window.
func (b *Batch) WindowBuffer(window Window, result *Buffer) {
	b.call("nvim_win_get_buf", result, window)
}

// SetBufferToWindow sets the current buffer in a window, without side-effects.
func (v *Nvim) SetBufferToWindow(window Window, buffer Buffer) error {
	return v.call("nvim_win_set_buf", nil, window, buffer)
}

// SetBufferToWindow sets the current buffer in a window, without side-effects.
func (b *Batch) SetBufferToWindow(window Window, buffer Buffer) {
	b.call("nvim_win_set_buf", nil, window, buffer)
}

// WindowCursor returns the cursor position in the window.
func (v *Nvim) WindowCursor(window Window) ([2]int, error) {
	var result [2]int
	err := v.call("nvim_win_get_cursor", &result, window)
	return result, err
}

// WindowCursor returns the cursor position in the window.
func (b *Batch) WindowCursor(window Window, result *[2]int) {
	b.call("nvim_win_get_cursor", result, window)
}

// SetWindowCursor sets the cursor position in the window to the given position.
func (v *Nvim) SetWindowCursor(window Window, pos [2]int) error {
	return v.call("nvim_win_set_cursor", nil, window, pos)
}

// SetWindowCursor sets the cursor position in the window to the given position.
func (b *Batch) SetWindowCursor(window Window, pos [2]int) {
	b.call("nvim_win_set_cursor", nil, window, pos)
}

// WindowHeight returns the window height.
func (v *Nvim) WindowHeight(window Window) (int, error) {
	var result int
	err := v.call("nvim_win_get_height", &result, window)
	return result, err
}

// WindowHeight returns the window height.
func (b *Batch) WindowHeight(window Window, result *int) {
	b.call("nvim_win_get_height", result, window)
}

// SetWindowHeight sets the window height.
func (v *Nvim) SetWindowHeight(window Window, height int) error {
	return v.call("nvim_win_set_height", nil, window, height)
}

// SetWindowHeight sets the window height.
func (b *Batch) SetWindowHeight(window Window, height int) {
	b.call("nvim_win_set_height", nil, window, height)
}

// WindowWidth returns the window width.
func (v *Nvim) WindowWidth(window Window) (int, error) {
	var result int
	err := v.call("nvim_win_get_width", &result, window)
	return result, err
}

// WindowWidth returns the window width.
func (b *Batch) WindowWidth(window Window, result *int) {
	b.call("nvim_win_get_width", result, window)
}

// SetWindowWidth sets the window width.
func (v *Nvim) SetWindowWidth(window Window, width int) error {
	return v.call("nvim_win_set_width", nil, window, width)
}

// SetWindowWidth sets the window width.
func (b *Batch) SetWindowWidth(window Window, width int) {
	b.call("nvim_win_set_width", nil, window, width)
}

// WindowVar gets a window-scoped (w:) variable.
func (v *Nvim) WindowVar(window Window, name string, result interface{}) error {
	return v.call("nvim_win_get_var", result, window, name)
}

// WindowVar gets a window-scoped (w:) variable.
func (b *Batch) WindowVar(window Window, name string, result interface{}) {
	b.call("nvim_win_get_var", result, window, name)
}

// SetWindowVar sets a window-scoped (w:) variable.
func (v *Nvim) SetWindowVar(window Window, name string, value interface{}) error {
	return v.call("nvim_win_set_var", nil, window, name, value)
}

// SetWindowVar sets a window-scoped (w:) variable.
func (b *Batch) SetWindowVar(window Window, name string, value interface{}) {
	b.call("nvim_win_set_var", nil, window, name, value)
}

// DeleteWindowVar removes a window-scoped (w:) variable.
func (v *Nvim) DeleteWindowVar(window Window, name string) error {
	return v.call("nvim_win_del_var", nil, window, name)
}

// DeleteWindowVar removes a window-scoped (w:) variable.
func (b *Batch) DeleteWindowVar(window Window, name string) {
	b.call("nvim_win_del_var", nil, window, name)
}

// WindowOption gets a window option.
func (v *Nvim) WindowOption(window Window, name string, result interface{}) error {
	return v.call("nvim_win_get_option", result, window, name)
}

// WindowOption gets a window option.
func (b *Batch) WindowOption(window Window, name string, result interface{}) {
	b.call("nvim_win_get_option", result, window, name)
}

// SetWindowOption sets a window option.
func (v *Nvim) SetWindowOption(window Window, name string, value interface{}) error {
	return v.call("nvim_win_set_option", nil, window, name, value)
}

// SetWindowOption sets a window option.
func (b *Batch) SetWindowOption(window Window, name string, value interface{}) {
	b.call("nvim_win_set_option", nil, window, name, value)
}

// WindowPosition gets the window position in display cells. First position is zero.
func (v *Nvim) WindowPosition(window Window) ([2]int, error) {
	var result [2]int
	err := v.call("nvim_win_get_position", &result, window)
	return result, err
}

// WindowPosition gets the window position in display cells. First position is zero.
func (b *Batch) WindowPosition(window Window, result *[2]int) {
	b.call("nvim_win_get_position", result, window)
}

// WindowTabpage gets the tab page that contains the window.
func (v *Nvim) WindowTabpage(window Window) (Tabpage, error) {
	var result Tabpage
	err := v.call("nvim_win_get_tabpage", &result, window)
	return result, err
}

// WindowTabpage gets the tab page that contains the window.
func (b *Batch) WindowTabpage(window Window, result *Tabpage) {
	b.call("nvim_win_get_tabpage", result, window)
}

// WindowNumber gets the window number from the window handle.
func (v *Nvim) WindowNumber(window Window) (int, error) {
	var result int
	err := v.call("nvim_win_get_number", &result, window)
	return result, err
}

// WindowNumber gets the window number from the window handle.
func (b *Batch) WindowNumber(window Window, result *int) {
	b.call("nvim_win_get_number", result, window)
}

// IsWindowValid returns true if the window is valid.
func (v *Nvim) IsWindowValid(window Window) (bool, error) {
	var result bool
	err := v.call("nvim_win_is_valid", &result, window)
	return result, err
}

// IsWindowValid returns true if the window is valid.
func (b *Batch) IsWindowValid(window Window, result *bool) {
	b.call("nvim_win_is_valid", result, window)
}

// SetWindowConfig configure window position. Currently this is only used to configure
// floating and external windows (including changing a split window to these
// types).
//
// See documentation at |nvim_open_win()|, for the meaning of parameters.
//
// When reconfiguring a floating window, absent option keys will not be
// changed. The following restriction apply: `row`, `col` and `relative`
// must be reconfigured together. Only changing a subset of these is an error.
func (v *Nvim) SetWindowConfig(window Window, config map[string]interface{}) error {
	return v.call("nvim_win_set_config", nil, window, config)
}

// SetWindowConfig configure window position. Currently this is only used to configure
// floating and external windows (including changing a split window to these
// types).
//
// See documentation at |nvim_open_win()|, for the meaning of parameters.
//
// When reconfiguring a floating window, absent option keys will not be
// changed. The following restriction apply: `row`, `col` and `relative`
// must be reconfigured together. Only changing a subset of these is an error.
func (b *Batch) SetWindowConfig(window Window, config map[string]interface{}) {
	b.call("nvim_win_set_config", nil, window, config)
}

// WindowConfig return window configuration.
//
// Return a dictionary containing the same config that can be given to
// |nvim_open_win()|.
//
// `relative` will be an empty string for normal windows.
func (v *Nvim) WindowConfig(window Window) (map[string]interface{}, error) {
	var result map[string]interface{}
	err := v.call("nvim_win_get_config", &result, window)
	return result, err
}

// WindowConfig return window configuration.
//
// Return a dictionary containing the same config that can be given to
// |nvim_open_win()|.
//
// `relative` will be an empty string for normal windows.
func (b *Batch) WindowConfig(window Window, result *map[string]interface{}) {
	b.call("nvim_win_get_config", result, window)
}

// CloseWindow close a window.
//
// This is equivalent to |:close| with count except that it takes a window id.
func (v *Nvim) CloseWindow(window Window, force bool) error {
	return v.call("nvim_win_close", nil, window, force)
}

// CloseWindow close a window.
//
// This is equivalent to |:close| with count except that it takes a window id.
func (b *Batch) CloseWindow(window Window, force bool) {
	b.call("nvim_win_close", nil, window, force)
}
